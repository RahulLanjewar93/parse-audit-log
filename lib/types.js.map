{"version":3,"file":"types.js","sourceRoot":"","sources":["../src/types.ts"],"names":[],"mappings":"","sourcesContent":["export type AuditLoggerOptions = {\n    /**\n     * The prefix to add for the audit classes. \n     * \n     * @default AUDIT_\n     * @example\n     * ```ts\n     * const Audit = new AuditLogger({\n     *  prefix: 'AUD_'\n     * })\n     * ```\n     */\n    prefix?: string,\n    /**\n     * The postfix to add for the audit classes. \n     * \n     * @example\n     * ```ts\n     * const Audit = new AuditLogger({\n     *  postfix: '_LOG'\n     * })\n     * ```\n     */\n    postfix?: string,\n    /**\n     * The parse sdk to use. \n     * Default to the global Parse SDK.\n     * \n     * @default Parse\n     */\n    parseClient?: any,\n    /**\n     * This options tells the audit logger if `allowClientClassCreation` is true or false.\n     * If it's set to true, then we need to register the schemas with the parse server, or use masterKey.\n     * \n     * @default true\n     */\n    allowClientClassCreation: boolean,\n    /**\n     * Use masterKey while creating audit objects.\n     * \n     * @default false\n     */\n    useMasterKey?: boolean,\n    /**\n     * This options tells the audit logger wether to log original and updated state.\n     * \n     * @default false\n     */\n    captureState: boolean,\n    /**\n     * Parse schemas to apply to the audit objects.\n     * \n    */\n    schemas?: {\n        save?: any[],\n        find?: any[],\n        delete?: any[],\n    };\n}\n\nexport type AuditObjectSaveOptions = {\n    // Extra data to add to the audit object, Will be added as a separate column.\n    extraData?: {\n        fieldName: string,\n        fieldValue: any,\n    }[];\n}"]}